#pragma kernel CSMain

struct Triangle {
    float2 vertexA;
    float2 vertexB;
    float2 vertexC;
};

RWStructuredBuffer<float3> _Vertices;
AppendStructuredBuffer<Triangle> _Triangles;
RWStructuredBuffer<int> _States;
uint _VoxelResolution;
uint _ChunkResolution;

int2 GetUV (int3 id) {
    return id.xy;
}

int indexFromCoord(int x, int y) {
    return y * _VoxelResolution + x + y;
}

void addTriangle(float2 a, float2 b, float2 c) {
    Triangle tri;
    tri.vertexA = a;
    tri.vertexB = b;
    tri.vertexC = c; 
    _Triangles.Append(tri);
}

void TriangulateCellRows(int2 uv) {
    if (uv.x >= _VoxelResolution || uv.y >= _VoxelResolution) {
      return;
    }

    float res = float(_VoxelResolution * _ChunkResolution);
    float resLen = (1.0 / res);

    int squareCornerStates[4] = {
        _States[indexFromCoord(uv.x, uv.y)],
        _States[indexFromCoord(uv.x + 1, uv.y)],
        _States[indexFromCoord(uv.x + 1, uv.y + 1)],
        _States[indexFromCoord(uv.x, uv.y + 1)],
    };

    int cellType = 0;
    if (squareCornerStates[0] > 0) cellType |= 1; //A
    if (squareCornerStates[1] > 0) cellType |= 2; //B
    if (squareCornerStates[2] > 0) cellType |= 4; //C
    if (squareCornerStates[3] > 0) cellType |= 8; //D

    float2 offset = float2(resLen * 0.5, resLen * 0.5);

    float2 A = float2(uv) / res;
    float2 B = float2(uv.x + 1, uv.y) / res;
    float2 C = float2(uv.x + 1, uv.y + 1) / res;
    float2 D = float2(uv.x, uv.y + 1) / res;

    float2 a = float2(A.x + resLen * 0.5, A.y) + offset;
    float2 b = float2(A.x + resLen, A.y + resLen * 0.5) + offset;
    float2 c = float2(A.x + resLen * 0.5, A.y + resLen) + offset;
    float2 d = float2(A.x, A.y + resLen * 0.5) + offset;

    float2 center = float2(A.x + resLen * 0.5, A.y + resLen * 0.5) + offset;

    float2 innerA = float2(A.x + resLen * 0.25, A.y + resLen * 0.25) + offset;
    float2 innerB = float2(A.x + resLen * 0.75, A.y + resLen * 0.25) + offset;
    float2 innerC = float2(A.x + resLen * 0.75, A.y + resLen * 0.75) + offset;
    float2 innerD = float2(A.x + resLen * 0.25, A.y + resLen * 0.75) + offset;

    A += offset;
    B += offset;
    C += offset;
    D += offset;

    Triangle tri;
    
    switch (cellType) {
      case 1: 
        addTriangle(a, A, d);
        break;
      case 2:  
        addTriangle(b, B, a);
        break;
      case 3:
        addTriangle(A, d, center);
        addTriangle(A, center, a);
        addTriangle(a, center, B);
        addTriangle(center, b, B);
        break;
      case 4: 
        addTriangle(c, C, b);
        break;
      case 5: 
        addTriangle(a, A, d);
        addTriangle(c, C, b);
        break;
      case 6:
        addTriangle(B, a, center);
        addTriangle(center, b, B);
        addTriangle(b, center, c);
        addTriangle(c, C, b);
        break;
      case 7: 
        addTriangle(A, d, a);
        addTriangle(d, center, a);
        addTriangle(d, innerD, center);
        addTriangle(B, a, center);
        addTriangle(B, center, b);
        addTriangle(b, center, c);
        addTriangle(b, c, C);
        addTriangle(center, innerD, c);
        break;
      case 8:  
        addTriangle(c, d, D);
        break;
      case 9:
        addTriangle(A, center, a);
        addTriangle(center, A, d);
        addTriangle(center, d, c);
        addTriangle(d, D, c);
        break;
      case 10: 
        addTriangle(b, B, a);
        addTriangle(c, d, D);
        break;
      case 11:
        addTriangle(a, A, d);
        addTriangle(a, d, center);
        addTriangle(B, a, center);
        addTriangle(B, center, b);
        addTriangle(b, center, innerC);
        addTriangle(center, d, D);
        addTriangle(center, D, c);
        addTriangle(center, c, innerC);
        break;
      case 12: 
        addTriangle(b, center, C);
        addTriangle(C, center, c);
        addTriangle(c, center, d);
        addTriangle(d, D, c);
        break;
      case 13: 
        addTriangle(a, A, d);
        addTriangle(a, d, center);
        addTriangle(a, center, innerB);
        addTriangle(innerB, center, b);
        addTriangle(b, center, c);
        addTriangle(b, c, C);
        addTriangle(center, d, D);
        addTriangle(center, D, c);
        break;
      case 14: 
        // addTriangle(D, C, d);
        // addTriangle(d, C, a);
        // addTriangle(a, C, B);
        addTriangle(innerA, center, a);
        addTriangle(B, a, center);
        addTriangle(B, center, b);
        addTriangle(b, center, c);
        addTriangle(b, c, C);
        addTriangle(center, d, D);
        addTriangle(center, D, c);
        addTriangle(center, innerA, d);
        break;
      case 15: 
        addTriangle(A, center, a);
        addTriangle(A, d, center);
        addTriangle(a, b, B);
        addTriangle(a, center, b);
        addTriangle(center, C, b);
        addTriangle(center, c, C);
        addTriangle(d, c, center);
        addTriangle(d, D, c);
        break;
    }
}

[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID)
{
    int2 uv = GetUV(id);
    TriangulateCellRows(uv);
}