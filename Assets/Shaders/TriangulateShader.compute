#pragma kernel CSMain

struct Triangle {
    float2 vertexA;
    float2 vertexB;
    float2 vertexC;
};

static int edges[16] = {
    0x0,
    0x3,
    0x6,
    0x5,
    0x12,
    0x15,
    0x10,
    0x9,
    0x9,
    0x10,
    0x15,
    0x12,
    0x5,
    0x6,
    0x3,
    0x0
};

static int triangulation[16][10] = {
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 4, -1, -1, -1, -1, -1, -1, -1},
    {1, 2, 5, -1, -1, -1, -1, -1, -1, -1},
    {0, 2, 4, 4, 2, 5, -1, -1, -1, -1},
    {2, 3, 6, -1, -1, -1, -1, -1, -1, -1},
    {0, 1, 4, 2, 3, 6, -1, -1, -1, -1},
    {1, 3, 5, 5, 6, 3, -1, -1, -1, -1},
    {0, 4, 5, 0, 3, 5, 3, 5, 6, -1},
    {0, 3, 7, -1, -1, -1, -1, -1, -1, -1},
    {1, 3, 4, 4, 7, 3, -1, -1, -1, -1},
    {0, 3, 7, 1, 2, 5, -1, -1, -1, -1},
    {3, 7, 4, 3, 2, 4, 2, 5, 4, -1},
    {0, 2, 7, 7, 6, 2, -1, -1, -1, -1},
    {1, 2, 7, 1, 7, 4, 2, 7, 6, -1},
    {0, 1, 6, 0, 6, 7, 1, 6, 5, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

static int relativeOffsets[8][2] = {
    {0, 0},
    {0, 1},
    {1, 0},
    {1, 1},
    {0, 0.5},
    {0.5, 0},
    {1, 0.5},
    {0.5, 1}
};

RWStructuredBuffer<float3> _Vertices;
AppendStructuredBuffer<Triangle> _Triangles;
RWStructuredBuffer<int> _States;
uint _VoxelResolution;
uint _ChunkResolution;

int2 GetUV (int3 id) {
    return id.xy;
}

int indexFromCoord(int x, int y) {
    return y * _VoxelResolution + x + y;
}

void addTriangle(float2 a, float2 b, float2 c) {
    Triangle tri;
    tri.vertexA = a;
    tri.vertexB = b;
    tri.vertexC = c; 
    _Triangles.Append(tri);
}

void TriangulateCellRows(int2 uv) {
    if (uv.x >= _VoxelResolution || uv.y >= _VoxelResolution) {
      return;
    }

    float res = float(_VoxelResolution * _ChunkResolution);
    float resLen = (1.0 / res);

    int squareCornerStates[4] = {
        _States[indexFromCoord(uv.x, uv.y)],
        _States[indexFromCoord(uv.x + 1, uv.y)],
        _States[indexFromCoord(uv.x + 1, uv.y + 1)],
        _States[indexFromCoord(uv.x, uv.y + 1)],
    };

    int cellType = 0;
    if (squareCornerStates[0] > 0) cellType |= 1; //A
    if (squareCornerStates[1] > 0) cellType |= 2; //B
    if (squareCornerStates[2] > 0) cellType |= 4; //C
    if (squareCornerStates[3] > 0) cellType |= 8; //D

    float2 offset = float2(resLen * 0.5, resLen * 0.5);

    float2 A = float2(uv) / res;
    float2 B = float2(uv.x + 1, uv.y) / res;
    float2 C = float2(uv.x + 1, uv.y + 1) / res;
    float2 D = float2(uv.x, uv.y + 1) / res;

    float2 a = float2(A.x + resLen * 0.5, A.y) + offset;
    float2 b = float2(A.x + resLen, A.y + resLen * 0.5) + offset;
    float2 c = float2(A.x + resLen * 0.5, A.y + resLen) + offset;
    float2 d = float2(A.x, A.y + resLen * 0.5) + offset;

    A += offset;
    B += offset;
    C += offset;
    D += offset;

    Triangle tri;
    
    switch (cellType) {
      case 1: 
        addTriangle(a, A, d);
        break;
      case 2:  
        addTriangle(b, B, a);
        break;
      case 3:  
        addTriangle(B, A, d);
        addTriangle(d, b, B);
        break;
      case 4: 
        addTriangle(c, C, b);
        break;
      case 5: 
        addTriangle(a, A, d);
        addTriangle(c, C, b);
        break;
      case 6:  
        addTriangle(B, c, C);
        addTriangle(a, c, B);
        break;
      case 7: 
        addTriangle(d, B, A);
        addTriangle(d, c, B);
        addTriangle(c, C, B);
        break;
      case 8:  
        addTriangle(c, d, D);
        break;
      case 9:  
        addTriangle(D, c, A);
        addTriangle(c, a, A);
        break;
      case 10: 
        addTriangle(b, B, a);
        addTriangle(c, d, D);
        break;
      case 11: 
        addTriangle(A, b, B);
        addTriangle(A, c, b);
        addTriangle(A, D, c);
        break;
      case 12: 
        addTriangle(D, C, d);
        addTriangle(d, C, b);
        break;
      case 13: 
        addTriangle(A, D, a);
        addTriangle(a, D, b);
        addTriangle(b, D, C);
        break;
      case 14: 
        addTriangle(D, C, d);
        addTriangle(d, C, a);
        addTriangle(a, C, B);
        break;
      case 15: 
        addTriangle(A, C, B);
        addTriangle(A, D, C);
        break;
    }
}

[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID)
{
    int2 uv = GetUV(id);
    TriangulateCellRows(uv);
}